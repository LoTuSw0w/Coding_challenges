# QUESTIONS:
 
Return the 'n'-th element in the Fibonacci sequence in an optimal way of O(n)

EXAMPLE:
```
Input: number = 7
Output: 13
```

# How I solve it:

This question is pretty much a fundamental recursion question, which we can solve by:

```python
def Fib_number(number:int):
    if number == 0:
        return 0
    if number <= 2:
        return 1
    return Fib_number(number - 1) + Fib_number(number - 2)
```

However, this approach is not very efficient. Since each instance of this function will span 2 additional instances, as a result, the run time complexity of this would be ~O(2^n), which is huge and unacceptable!

To reduce the run time of this function, we can use a memorization object to store the unique value generated by an instance of this function, so we don't have to execute it again. In python, we can achieve this using a function decorator. The runtime of this method is now reduced to O(n).

```python
def Memorization(f):
    memo = {}
    def save_memo_and_pass_param(number):
        if number not in memo:
            memo[number] = f(number)
        return memo[number]
    return save_memo_and_pass_param
```